{
  "author": {
    "name": "Diogo Resende",
    "email": "dresende@thinkdigital.pt"
  },
  "name": "orm",
  "description": "NodeJS Object-relational mapping",
  "keywords": [
    "orm",
    "odm",
    "database",
    "mysql",
    "postgres",
    "redshift",
    "sqlite"
  ],
  "version": "2.0.2",
  "license": "MIT",
  "repository": {
    "url": "http://dresende.github.com/node-orm2"
  },
  "scripts": {
    "test": "make test"
  },
  "contributors": [
    {
      "name": "Bramus Van Damme",
      "email": "bramus@bram.us"
    },
    {
      "name": "Lorien Gamaroff",
      "email": "lorien@gamaroff.org"
    },
    {
      "name": "preslavrachev"
    },
    {
      "name": "Chris Cowan",
      "email": "me@chriscowan.us"
    },
    {
      "name": "Paul Dixon",
      "email": "paul.dixon@mintbridge.co.uk"
    },
    {
      "name": "David Kosub"
    }
  ],
  "main": "./lib/ORM",
  "engines": {
    "node": "*"
  },
  "analyse": false,
  "devDependencies": {
    "utest": "0.0.6",
    "urun": "0.0.6",
    "mysql": "2.0.0-alpha7",
    "pg": "0.8.7",
    "sqlite3": "2.1.5"
  },
  "optionalDependencies": {},
  "readme": "## Object Relational Mapping\n\n[![Build Status](https://secure.travis-ci.org/dresende/node-orm2.png)](http://travis-ci.org/dresende/node-orm2)\n\n## Install\n\n```sh\nnpm install orm\n```\n\nCurrent stable version: **2.0.2**\n\n## DBMS Support\n\n- MySQL\n- PostgreSQL\n- Amazon Redshift\n- SQLite\n\n## Features\n\n- Create Models, sync, drop, bulk create, get, find, remove, count\n- Create Model associations, find, check, create and remove\n- Define custom validations (several builtin validations, check instance properties before saving)\n- Instance singleton (table rows fetched twice are the same object, changes to one change all)\n\n## Introduction\n\nThis is a node.js object relational mapping module.\n\nHere is an example on how to use it:\n\n```js\nvar orm = require(\"orm\");\n\norm.connect(\"mysql://username:password@host/database\", function (err, db) {\n\tif (err) throw err;\n\n\tvar Person = db.define(\"person\", {\n\t\tname      : String,\n\t\tsurname   : String,\n\t\tage       : Number,\n\t\tmale      : Boolean,\n\t\tcontinent : [ \"Europe\", \"America\", \"Asia\", \"Africa\", \"Australia\", \"Antartica\" ], // ENUM type\n\t\tphoto     : Buffer, // BLOB/BINARY\n\t\tdata      : Object // JSON encoded\n\t}, {\n\t\tmethods: {\n\t\t\tfullName: function () {\n\t\t\t\treturn this.name + ' ' + this.surname;\n\t\t\t}\n\t\t},\n\t\tvalidations: {\n\t\t\tage: orm.validators.rangeNumber(18, undefined, \"under-age\")\n\t\t}\n\t});\n\n\tPerson.find({ surname: \"Doe\" }, function (err, people) {\n\t\t// SQL: \"SELECT * FROM person WHERE surname = 'Doe'\"\n\n\t\tconsole.log(\"People found: %d\", people.length);\n\t\tconsole.log(\"First person: %s, age %d\", people[0].fullName(), people[0].age);\n\n\t\tpeople[0].age = 16;\n\t\tpeople[0].save(function (err) {\n\t\t\t// err.msg = \"under-age\";\n\t\t});\n\t});\n});\n```\n\n## Settings\n\nYou have a global settings object and one for each connection.\n\n```js\nvar orm = require(\"orm\");\n\norm.settings.set(\"some.deep.value\", 123);\n\norm.connect(\"....\", function (err, db) {\n    // db.settings is a snapshot of the settings at the moment\n    // of orm.connect(). changes to it don't affect orm.settings\n\n\tconsole.log(db.settings.get(\"some.deep.value\")); // 123\n\tconsole.log(db.settings.get(\"some.deep\"));       // { value: 123 }\n});\n```\n\n## Models\n\nA Model is a structure binded to one or more tables, depending on the associations. The model name is assumed to be the table name. After defining a model you can use it to manipulate the table.\n\nAfter defining a Model you can get a specific element or find one or more based on some conditions.\n\n## Defining Models\n\nTo define a model, you use the reference to the database connection and call `define`. The function will define a Model\nand will return it to you. You can get it later by it's id directly from the database connection so you don't actually\nneed to store a reference to it.\n\n```js\nvar Person = db.define('person', {        // 'person' will be the table in the database as well as the model id\n\t// properties\n\tname    : String,                     // you can use native objects to define the property type\n\tsurname : { type: \"text\", size: 50 }  // or you can be specific and define aditional options\n}, {\n\t// options (optional)\n});\n```\n\n## Loading Models\n\nIf you prefer to have your models defined in separated files, you can define them in a function inside a module and\nexport the function has the entire module. You can have cascading loads.\n\n```js\n// your main file (after connecting)\ndb.load(\"./models\", function (err) {\n    // loaded!\n    var Person = db.models.person;\n    var Pet    = db.models.pet;\n});\n\n// models.js\nmodule.exports = function (db, cb) {\n    db.load(\"./models-extra\", function (err) {\n        if (err) {\n            return cb(err);\n        }\n\n        db.define('person', {\n            name : String\n        });\n\n        return cb();\n    });\n};\n\n// models-extra.js\nmodule.exports = function (db, cb) {\n    db.define('pet', {\n        name : String\n    });\n\n    return cb();\n};\n```\n\n## Synching Models\n\nIf you don't have the tables on the database you have to call the `.sync()` on every Model. This will just create the\ntables necessary for your Model. If you have more than one Model you can call `.sync()` directly on the database\nconnection to syncronize all Models.\n\n```js\n// db.sync() can also be used\nPerson.sync(function (err) {\n\t!err && console.log(\"done!\");\n});\n```\n\n## Dropping Models\n\nIf you want to drop a Model and remove all tables you can use the `.drop()` method.\n\n```js\nPerson.drop(function (err) {\n\t!err && console.log(\"person model no longer exists!\");\n});\n```\n\n## Advanced Options\n\nUsing [Settings](#settings) or directly on Model definition you can tweak some options.\nFor example, each Model instance has a unique ID in the database. This table column is\nby default \"id\" but you can change it.\n\n```js\nvar Person = db.define(\"person\", {\n\tname : String\n}, {\n\tid   : \"person_id\"\n});\n\n// or just do it globally..\ndb.settings.set(\"properties.primary_key\", \"UID\");\n\n// ..and then define your Models\nvar Pet = db.define(\"pet\", {\n\tname : String\n});\n```\n\n**Pet** model will have 2 columns, an `UID` and a `name`.\n\nOther options:\n\n- `cache` : (default: `true`) Set it to `false` to disable Instance cache (Singletons) or set a timeout value (in seconds);\n- `autoSave` : (default: `false`) Set it to `true` to save an Instance right after changing any property;\n- `autoFetch` : (default: `false`) Set it to `true` to fetch associations when fetching an instance from the database;\n- `autoFetchLimit` : (default: `1`) If `autoFetch` is enabled this defines how many hoops (associations of associations)\n  you want it to automatically fetch.\n\n## Hooks\n\nIf you want to listen for a type of event than occurs in instances of a Model, you can attach a function that\nwill be called when that event happens. There are some events possible:\n\n- `afterLoad` : (no parameters) Right after loading and preparing an instance to be used;\n- `beforeSave` : (no parameters) Right before trying to save;\n- `afterSave` : (bool success) Right after saving;\n- `beforeCreate` : (no parameters) Right before trying to save a new instance;\n- `beforeRemove` : (no parameters) Right before trying to remove an instance.\n\nAll hook function are called with `this` as the instance so you can access anything you want related to it.\n\n## Finding Items\n\n### Model.get(id, [ options ], cb)\n\nTo get a specific element from the database use `Model.get`.\n\n```js\nPerson.get(123, function (err, person) {\n\t// finds person with id = 123\n});\n```\n\n### Model.find([ conditions ] [, options ] [, limit ] [, order ] [, cb ])\n\nFinding one or more elements has more options, each one can be given in no specific parameter order. Only `options` has to be after `conditions` (even if it's an empty object).\n\n```js\nPerson.find({ name: \"John\", surname: \"Doe\" }, 3, function (err, people) {\n\t// finds people with name='John' AND surname='Doe' and returns the first 3\n});\n```\n\nIf you need to sort the results because you're limiting or just because you want them sorted do:\n\n```js\nPerson.find({ surname: \"Doe\" }, \"name\", function (err, people) {\n\t// finds people with surname='Doe' and returns sorted by name ascending\n});\nPerson.find({ surname: \"Doe\" }, [ \"name\", \"Z\" ], function (err, people) {\n\t// finds people with surname='Doe' and returns sorted by name descending\n\t// ('Z' means DESC; 'A' means ASC - default)\n});\n```\n\nThere are more options that you can pass to find something. These options are passed in a second object:\n\n```js\nPerson.find({ surname: \"Doe\" }, { offset: 2 }, function (err, people) {\n\t// finds people with surname='Doe', skips the first 2 and returns the others\n});\n```\n\n### Model.count([ conditions, ] cb)\n\nIf you just want to count the number of items that match a condition you can just use `.count()` instead of finding all\nof them and counting. This will actually tell the database server to do a count, the count is not done in javascript.\n\n```js\nPerson.count({ surname: \"Doe\" }, function (err, count) {\n\tconsole.log(\"We have %d Does in our db\", count);\n});\n```\n\n### Model.exists([ conditions, ] cb)\n\nSimilar to `.count()`, this method just checks if the count is greater than zero or not.\n\n```js\nPerson.exists({ surname: \"Doe\" }, function (err, exists) {\n\tconsole.log(\"We %s Does in our db\", exists ? \"have\" : \"don't have\");\n});\n```\n\n### Available options\n\n- `offset`: discards the first `N` elements\n- `limit`: although it can be passed as a direct argument, you can use it here if you prefer\n- `only`: if you don't want all properties, you can give an array with the list of properties you want\n\n#### Chaining\n\nIf you prefer another less complicated syntax you can chain `.find()` by not giving a callback parameter.\n\n```js\nPerson.find({ surname: \"Doe\" }).limit(3).offset(2).only(\"name\", \"surname\").run(function (err, people) {\n    // finds people with surname='Doe', skips first 2 and limits to 3 elements,\n    // returning only 'name' and 'surname' properties\n});\n```\n\nYou can also chain and just get the count in the end. In this case, offset, limit and order are ignored.\n\n```js\nPerson.find({ surname: \"Doe\" }).count(function (err, people) {\n    // people = number of people with surname=\"Doe\"\n});\n```\n\nAlso available is the option to remove the selected items.\n\n```js\nPerson.find({ surname: \"Doe\" }).remove(function (err) {\n    // Does gone..\n});\n```\n\nYou can also make modifications to your instances using common Array traversal methods and save everything\nin the end.\n\n```js\nPerson.find({ surname: \"Doe\" }).each(function (person) {\n\tperson.surname = \"Dean\";\n}).save(function (err) {\n\t// done!\n});\n\nPerson.find({ surname: \"Doe\" }).each().filter(function (person) {\n\treturn person.age >= 18;\n}).sort(function (person1, person2) {\n\treturn person1.age < person2.age;\n}).get(function (people) {\n\t// get all people with at least 18 years, sorted by age\n});\n```\n\nOf course you could do this directly on `.find()`, but for some more complicated tasks this can be very usefull.\n\n`Model.find()` does not return an Array so you can't just chain directly. To start chaining you have to call\n`.each()` (with an optional callback if you want to traverse the list). You can then use the common functions\n`.filter()`, `.sort()` and `.forEach()` more than once.\n\nIn the end (or during the process..) you can call:\n- `.count()` if you just want to know how many items there are;\n- `.get()` to retrieve the list;\n- `.save()` to save all item changes.\n\n#### Conditions\n\nConditions are defined as an object where every key is a property (table column). All keys are supposed\nto be concatenated by the logical `AND`. Values are considered to match exactly, unless you're passing\nan `Array`. In this case it is considered a list to compare the property with.\n\n```js\n{ col1: 123, col2: \"foo\" } // `col1` = 123 AND `col2` = 'foo'\n{ col1: [ 1, 3, 5 ] } // `col1` IN (1, 3, 5)\n```\n\nIf you need other comparisons, you have to use a special object created by some helper functions. Here are\na few examples to describe it:\n\n```js\n{ col1: orm.eq(123) } // `col1` = 123 (default)\n{ col1: orm.ne(123) } // `col1` <> 123\n{ col1: orm.gt(123) } // `col1` > 123\n{ col1: orm.gte(123) } // `col1` >= 123\n{ col1: orm.lt(123) } // `col1` < 123\n{ col1: orm.lte(123) } // `col1` <= 123\n{ col1: orm.between(123, 456) } // `col1` BETWEEN 123 AND 456\n```\n\n### Singleton\n\nEach model instances is cached, so if you fetch the same record using 2 or more different queries, you will\nget the same object. If you have other systems that can change your database (or you're developing and need\nto make some manual changes) you should remove this feature by disabling cache. You do this when you're\ndefining each Model.\n\n```js\nvar Person = db.define('person', {\n\tname    : String\n}, {\n\tcache   : false\n});\n```\n\nIf you want singletons but want cache to expire after a period of time, you can pass a number instead of a\nboolean. The number will be considered the cache timeout in seconds (you can use floating point).\n\n## Associations\n\nAn association is a relation between one or more tables.\n\n## hasOne vs. hasMany\n\nSince this topic brings some confusion to many people including myself, here's a list of the possibilities\nsupported by both types of association.\n\n- `hasOne` : it's a **Many-to-One** relationship. A.hasOne(B) means A will have one (or none) of B, but B can be\n  associated with many A;\n- `hasMany`: it's a **One-to-Many** relationship. A.hasMany(B) means A will have none, one or more of B. Actually\n  B will be associated with possibly many A but you don't have how to find it easily (see next);\n- `hasMany` + reverse: it's a **Many-to-Many** relationship. A.hasMany(B, { reverse: A }) means A can have none or\n  many B and also B can have none or many A. Accessors will be created in both models so you can manage them from\n  both sides.\n\nIf you have a relation of 1 to 0 or 1 to 1, you should use `hasOne` association. This assumes a column in the model that has the id of the other end of the relation.\n\n```js\nvar Person = db.define('person', {\n\tname : String\n});\nvar Animal = db.define('animal', {\n\tname : String\n});\nAnimal.hasOne(\"owner\", Person); // assumes column 'owner_id' in 'animal' table\n\n// get animal with id = 123\nAnimal.get(123, function (err, Foo) {\n\t// Foo is the animal model instance, if found\n\tFoo.getOwner(function (err, John) {\n\t\t// if Foo animal has really an owner, John points to it\n\t});\n});\n```\n\nIf you prefer to use another name for the field (owner_id) you can change this parameter in the settings.\n\n```js\ndb.settings.set(\"properties.association_key\", \"id_{name}\"); // {name} will be replaced by 'owner' in this case\n```\n\n**Note: This has to be done prior to the association creation.**\n\nFor relations of 1 to many you have to use `hasMany` associations. This assumes another table that has 2 columns, one for each table in the association.\n\n```js\nvar Person = db.define('person', {\n\tname : String\n});\nPerson.hasMany(\"friends\"); // omitting the other Model, it will assume self model\n\nPerson.get(123, function (err, John) {\n\tJohn.getFriends(function (err, friends) {\n\t\t// assumes table person_friends with columns person_id and friends_id\n\t});\n});\n```\n\nThe `hasMany` associations can have additional properties that are assumed to be in the association table.\n\n```js\nvar Person = db.define('person', {\n\tname : String\n});\nPerson.hasMany(\"friends\", {\n    rate : Number\n});\n\nPerson.get(123, function (err, John) {\n\tJohn.getFriends(function (err, friends) {\n\t\t// assumes rate is another column on table person_friends\n\t\t// you can access it by going to friends[N].extra.rate\n\t});\n});\n```\n\nIf you prefer you can activate `autoFetch`. This way associations are automatically fetched when you get or find instances of a model.\n\n```js\nvar Person = db.define('person', {\n\tname : String\n});\nPerson.hasMany(\"friends\", {\n    rate : Number\n}, {\n    autoFetch : true\n});\n\nPerson.get(123, function (err, John) {\n    // no need to do John.getFriends() , John already has John.friends Array\n});\n```\n\nYou can also define this option globally instead of a per association basis.\n\n```js\nvar Person = db.define('person', {\n\tname : String\n}, {\n    autoFetch : true\n});\nPerson.hasMany(\"friends\", {\n    rate : Number\n});\n```\n\nAssociations can make calls to the associated Model by using the `reverse` option. For example, if you have an\nassociation from ModelA to ModelB, you can create an accessor in ModelB to get instances from ModelA.\nConfusing? Look at the next example.\n\n```js\nvar Pet = db.define('pet', {\n\tname : String\n});\nvar Person = db.define('person', {\n\tname : String\n});\nPet.hasOne(\"owner\", Person, {\n\treverse : \"pets\"\n});\n\nPerson(4).getPets(function (err, pets) {\n\t// although the association was made on Pet,\n\t// Person will have an accessor (getPets)\n\t//\n\t// In this example, ORM will fetch all pets\n\t// whose owner_id = 4\n});\n```\n\nThis makes even more sense when having `hasMany` associations since you can manage the Many-to-Many associations\nfrom both sides.\n\n\n```js\nvar Pet = db.define('pet', {\n\tname : String\n});\nvar Person = db.define('person', {\n\tname : String\n});\nPerson.hasMany(\"pets\", Person, {\n    bought  : Date\n}, {\n\treverse : \"owners\"\n});\n\nPerson(1).getPets(...);\nPet(2).getOwners(...);\n```\n",
  "readmeFilename": "Readme.md",
  "_id": "orm@2.0.2",
  "dependencies": {},
  "dist": {
    "shasum": "61787e899408199b83a576f3a1157d5e34c5c684"
  },
  "_from": "orm@",
  "_resolved": "https://registry.npmjs.org/orm/-/orm-2.0.2.tgz"
}
